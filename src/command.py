"""
Command/Control Architecture for AI Commanders Space Battle Simulator.

This module implements the hierarchical control system for ship AI, providing:
- Command types (dataclasses) for ship control
- TacticalController for rule-based behavior between LLM decision points
- StrategicController interface for LLM integration
- BattleState for battle snapshot representation

The architecture follows a strategic/tactical split where LLMs make high-level
decisions at intervals, while simple rule-based controllers handle moment-to-moment
execution of those decisions.
"""

from __future__ import annotations

import math
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Optional, Protocol, Sequence

import numpy as np
from numpy.typing import NDArray


# =============================================================================
# Type Aliases
# =============================================================================

Vector3 = NDArray[np.float64]  # 3D vector [x, y, z]
ShipId = str
WeaponSlot = str


# =============================================================================
# Command Types
# =============================================================================

@dataclass(frozen=True)
class SetThrust:
    """
    Command to set the ship's thrust vector and magnitude.

    The ship will apply thrust in the specified direction at the given
    magnitude (0.0 to 1.0 as fraction of max thrust).

    Attributes:
        vector: Normalized 3D direction vector for thrust application.
        magnitude: Thrust level from 0.0 (no thrust) to 1.0 (maximum thrust).
    """
    vector: Vector3
    magnitude: float

    def __post_init__(self) -> None:
        if not 0.0 <= self.magnitude <= 1.0:
            raise ValueError(f"Magnitude must be between 0.0 and 1.0, got {self.magnitude}")


@dataclass(frozen=True)
class RotateTo:
    """
    Command to rotate the ship to face a specific bearing.

    The ship will use RCS thrusters to rotate until the nose points
    in the specified direction.

    Attributes:
        target_bearing: Normalized 3D vector indicating desired facing direction.
    """
    target_bearing: Vector3


@dataclass(frozen=True)
class Engage:
    """
    Command to engage a specific target with designated weapons.

    The weapons officer will target the specified ship and fire when
    firing solutions are available.

    Attributes:
        target_id: Unique identifier of the ship to engage.
        weapon_slots: List of weapon slot identifiers to use for engagement.
    """
    target_id: ShipId
    weapon_slots: tuple[WeaponSlot, ...]

    def __init__(self, target_id: ShipId, weapon_slots: Sequence[WeaponSlot]) -> None:
        object.__setattr__(self, 'target_id', target_id)
        object.__setattr__(self, 'weapon_slots', tuple(weapon_slots))


@dataclass(frozen=True)
class HoldFire:
    """
    Command to cease all weapons fire.

    All weapons will stop firing and clear their targeting solutions.
    Point defense may optionally continue operating based on configuration.

    Attributes:
        include_point_defense: If True, also stops point defense. Default False.
    """
    include_point_defense: bool = False


@dataclass(frozen=True)
class Evade:
    """
    Command to execute evasive maneuvers against a specific threat.

    The helmsman will execute appropriate evasive patterns to avoid
    the specified threat (typically a torpedo or incoming projectile).

    Attributes:
        threat_id: Unique identifier of the threat to evade.
    """
    threat_id: str


# Union type for all commands
Command = SetThrust | RotateTo | Engage | HoldFire | Evade


# =============================================================================
# Event Types (for tactical controller callbacks)
# =============================================================================

class TacticalEventType(Enum):
    """Types of events that may trigger LLM callback."""
    TARGET_DESTROYED = auto()
    TARGET_LOST = auto()
    WEAPONS_DEPLETED = auto()
    TORPEDO_INCOMING = auto()
    CRITICAL_DAMAGE = auto()
    HEAT_CRITICAL = auto()
    MANEUVER_COMPLETE = auto()
    FIRING_SOLUTION_ACQUIRED = auto()
    FIRING_SOLUTION_LOST = auto()
    ENEMY_MANEUVER_DETECTED = auto()
    LOW_DELTA_V = auto()


@dataclass
class TacticalEvent:
    """
    Event generated by tactical controller that may warrant LLM attention.

    Attributes:
        event_type: The type of tactical event.
        priority: Urgency level from 1 (low) to 5 (critical).
        details: Additional context about the event.
        timestamp: Simulation time when event occurred.
    """
    event_type: TacticalEventType
    priority: int
    details: dict
    timestamp: float


# =============================================================================
# Ship State Types
# =============================================================================

@dataclass
class ShipState:
    """
    Complete state of a single ship at a point in time.

    Attributes:
        ship_id: Unique identifier for this ship.
        position: 3D position in meters.
        velocity: 3D velocity in meters per second.
        heading: Normalized 3D vector indicating nose direction.
        angular_velocity: Rotation rate in radians per second.
        hull_hp: Dict mapping module name to (current_hp, max_hp).
        heat_percentage: Current heat level as percentage of max (0-100).
        battery_percentage: Current battery charge as percentage (0-100).
        delta_v_remaining: Remaining delta-v in meters per second.
        weapons_status: Dict mapping weapon slot to weapon state dict.
        is_destroyed: Whether the ship has been destroyed.
        is_disabled: Whether the ship is combat-ineffective.
    """
    ship_id: ShipId
    position: Vector3
    velocity: Vector3
    heading: Vector3
    angular_velocity: Vector3
    hull_hp: dict[str, tuple[float, float]]
    heat_percentage: float
    battery_percentage: float
    delta_v_remaining: float
    weapons_status: dict[WeaponSlot, dict]
    is_destroyed: bool = False
    is_disabled: bool = False


@dataclass
class ThreatInfo:
    """
    Information about a detected threat (torpedo, projectile, etc.).

    Attributes:
        threat_id: Unique identifier for this threat.
        threat_type: Category of threat ('torpedo', 'projectile', 'ship').
        position: 3D position in meters.
        velocity: 3D velocity in meters per second.
        estimated_time_to_impact: Seconds until potential impact.
        source_ship_id: ID of the ship that launched this threat, if known.
        can_be_intercepted: Whether PD can engage this threat.
    """
    threat_id: str
    threat_type: str
    position: Vector3
    velocity: Vector3
    estimated_time_to_impact: float
    source_ship_id: Optional[ShipId] = None
    can_be_intercepted: bool = True


@dataclass
class ProjectileInfo:
    """
    Information about an active projectile in the battlespace.

    Attributes:
        projectile_id: Unique identifier.
        projectile_type: Type of projectile ('slug', 'torpedo', etc.).
        position: 3D position in meters.
        velocity: 3D velocity in meters per second.
        source_ship_id: ID of ship that fired this projectile.
        target_ship_id: Intended target, if guided.
        is_guided: Whether projectile can adjust course.
    """
    projectile_id: str
    projectile_type: str
    position: Vector3
    velocity: Vector3
    source_ship_id: ShipId
    target_ship_id: Optional[ShipId] = None
    is_guided: bool = False


# =============================================================================
# Battle State
# =============================================================================

@dataclass
class BattleState:
    """
    Complete snapshot of the battle at a specific point in time.

    This is the primary data structure passed to strategic controllers
    for decision-making. It contains all information visible to the
    ship's sensors and systems.

    Attributes:
        timestamp: Simulation time in seconds since battle start.
        own_ship: Complete state of the controlled ship.
        enemy_ships: List of detected enemy ship states (may be incomplete
            based on sensor data).
        friendly_ships: List of allied ship states, if any.
        incoming_threats: List of detected threats targeting own ship.
        active_projectiles: List of all tracked projectiles in battlespace.
        recent_events: Events from the last decision interval.
        engagement_range: Distance to primary target in meters.
        closing_rate: Rate of closure with primary target in m/s.
        battle_duration: Total elapsed battle time in seconds.
    """
    timestamp: float
    own_ship: ShipState
    enemy_ships: list[ShipState]
    friendly_ships: list[ShipState]
    incoming_threats: list[ThreatInfo]
    active_projectiles: list[ProjectileInfo]
    recent_events: list[TacticalEvent]
    engagement_range: float
    closing_rate: float
    battle_duration: float

    @property
    def primary_target(self) -> Optional[ShipState]:
        """Returns the closest enemy ship, if any exist."""
        if not self.enemy_ships:
            return None
        # Find closest by position
        own_pos = self.own_ship.position
        return min(
            self.enemy_ships,
            key=lambda s: np.linalg.norm(s.position - own_pos)
        )

    @property
    def critical_threats(self) -> list[ThreatInfo]:
        """Returns threats with less than 30 seconds to impact."""
        return [t for t in self.incoming_threats if t.estimated_time_to_impact < 30.0]

    def get_threat_by_id(self, threat_id: str) -> Optional[ThreatInfo]:
        """Look up a specific threat by ID."""
        for threat in self.incoming_threats:
            if threat.threat_id == threat_id:
                return threat
        return None


# =============================================================================
# Tactical Controller
# =============================================================================

class TacticalController:
    """
    Executes commands between LLM decision points using rule-based behaviors.

    The tactical controller handles moment-to-moment execution of strategic
    commands issued by the LLM. It implements simple, deterministic behaviors
    that don't require high-level reasoning.

    Key behaviors:
    - "keep nose toward target": Maintains orientation toward engage target
    - "fire when in range": Automatically fires weapons with valid solutions
    - "evade incoming torpedoes": Executes pre-programmed evasive patterns

    The controller generates TacticalEvents when situations arise that may
    warrant LLM intervention.

    Attributes:
        ship_id: ID of the ship this controller manages.
        active_commands: Currently executing command list.
        weapon_range_limits: Dict of weapon slot to max effective range.
        point_defense_auto: Whether PD operates autonomously.
        evade_threshold_seconds: Threat ETA that triggers auto-evade.
    """

    # Default weapon ranges in meters
    DEFAULT_WEAPON_RANGES: dict[str, float] = {
        'turret_dorsal': 200_000,
        'turret_ventral': 200_000,
        'spinal': 500_000,
        'pd_forward': 100_000,
        'pd_aft': 100_000,
        'torpedo': 1_000_000,
    }

    def __init__(
        self,
        ship_id: ShipId,
        weapon_range_limits: Optional[dict[WeaponSlot, float]] = None,
        point_defense_auto: bool = True,
        evade_threshold_seconds: float = 60.0,
    ) -> None:
        """
        Initialize the tactical controller.

        Args:
            ship_id: ID of the controlled ship.
            weapon_range_limits: Custom weapon range limits, or use defaults.
            point_defense_auto: Enable automatic PD engagement.
            evade_threshold_seconds: Threat ETA threshold for auto-evade warning.
        """
        self.ship_id = ship_id
        self.active_commands: list[Command] = []
        self.weapon_range_limits = weapon_range_limits or self.DEFAULT_WEAPON_RANGES.copy()
        self.point_defense_auto = point_defense_auto
        self.evade_threshold_seconds = evade_threshold_seconds

        # Internal state tracking
        self._current_engage_target: Optional[ShipId] = None
        self._evading_threat: Optional[str] = None
        self._last_known_enemy_positions: dict[ShipId, Vector3] = {}

    def set_commands(self, commands: list[Command]) -> None:
        """
        Set the active command list for execution.

        Clears any previously active commands and begins executing
        the new command list.

        Args:
            commands: List of commands to execute.
        """
        self.active_commands = list(commands)

        # Update internal state based on new commands
        self._current_engage_target = None
        self._evading_threat = None

        for cmd in commands:
            if isinstance(cmd, Engage):
                self._current_engage_target = cmd.target_id
            elif isinstance(cmd, Evade):
                self._evading_threat = cmd.threat_id

    def update(
        self,
        battle_state: BattleState,
        delta_time: float,
    ) -> tuple[dict, list[TacticalEvent]]:
        """
        Execute one tactical update cycle.

        Processes the current battle state and active commands to produce
        low-level control outputs and any events that warrant LLM attention.

        Args:
            battle_state: Current snapshot of the battle.
            delta_time: Time elapsed since last update in seconds.

        Returns:
            Tuple of (control_outputs, events) where:
            - control_outputs: Dict of control signals for ship systems.
            - events: List of events that may trigger LLM callback.
        """
        events: list[TacticalEvent] = []
        control_outputs: dict = {
            'thrust_vector': np.zeros(3),
            'thrust_magnitude': 0.0,
            'target_heading': None,
            'weapons_fire': {},
            'point_defense_targets': [],
        }

        # Track enemy positions for maneuver detection
        self._detect_enemy_maneuvers(battle_state, events)

        # Process each active command
        for cmd in self.active_commands:
            if isinstance(cmd, SetThrust):
                control_outputs['thrust_vector'] = cmd.vector
                control_outputs['thrust_magnitude'] = cmd.magnitude

            elif isinstance(cmd, RotateTo):
                control_outputs['target_heading'] = cmd.target_bearing

            elif isinstance(cmd, Engage):
                self._process_engage(cmd, battle_state, control_outputs, events)

            elif isinstance(cmd, HoldFire):
                self._process_hold_fire(cmd, control_outputs)

            elif isinstance(cmd, Evade):
                self._process_evade(cmd, battle_state, control_outputs, events)

        # Autonomous behaviors
        if self.point_defense_auto:
            self._auto_point_defense(battle_state, control_outputs)

        self._check_critical_conditions(battle_state, events)

        return control_outputs, events

    def _process_engage(
        self,
        cmd: Engage,
        battle_state: BattleState,
        outputs: dict,
        events: list[TacticalEvent],
    ) -> None:
        """Process an engage command - maintain orientation and fire when able."""
        # Find target
        target = None
        for ship in battle_state.enemy_ships:
            if ship.ship_id == cmd.target_id:
                target = ship
                break

        if target is None:
            # Target lost
            events.append(TacticalEvent(
                event_type=TacticalEventType.TARGET_LOST,
                priority=4,
                details={'target_id': cmd.target_id},
                timestamp=battle_state.timestamp,
            ))
            return

        if target.is_destroyed:
            events.append(TacticalEvent(
                event_type=TacticalEventType.TARGET_DESTROYED,
                priority=3,
                details={'target_id': cmd.target_id},
                timestamp=battle_state.timestamp,
            ))
            return

        # "Keep nose toward target" behavior
        target_direction = target.position - battle_state.own_ship.position
        target_direction = target_direction / np.linalg.norm(target_direction)
        outputs['target_heading'] = target_direction

        # Calculate range to target
        range_to_target = np.linalg.norm(target.position - battle_state.own_ship.position)

        # "Fire when in range" behavior for each designated weapon
        for weapon_slot in cmd.weapon_slots:
            max_range = self.weapon_range_limits.get(weapon_slot, 100_000)

            if range_to_target <= max_range:
                # Check if weapon is ready (simplified check)
                weapon_status = battle_state.own_ship.weapons_status.get(weapon_slot, {})
                if weapon_status.get('status') == 'ready':
                    outputs['weapons_fire'][weapon_slot] = {
                        'target_id': cmd.target_id,
                        'fire': True,
                    }

                    if weapon_slot not in outputs.get('_notified_solutions', set()):
                        events.append(TacticalEvent(
                            event_type=TacticalEventType.FIRING_SOLUTION_ACQUIRED,
                            priority=2,
                            details={
                                'weapon_slot': weapon_slot,
                                'target_id': cmd.target_id,
                                'range': range_to_target,
                            },
                            timestamp=battle_state.timestamp,
                        ))
                        outputs.setdefault('_notified_solutions', set()).add(weapon_slot)

    def _process_hold_fire(self, cmd: HoldFire, outputs: dict) -> None:
        """Process hold fire command - clear all weapon fire commands."""
        outputs['weapons_fire'] = {}
        if cmd.include_point_defense:
            outputs['point_defense_targets'] = []

    def _process_evade(
        self,
        cmd: Evade,
        battle_state: BattleState,
        outputs: dict,
        events: list[TacticalEvent],
    ) -> None:
        """
        Process evade command - execute evasive maneuver against threat.

        Uses a simple perpendicular thrust pattern to evade incoming threats.
        """
        threat = battle_state.get_threat_by_id(cmd.threat_id)

        if threat is None:
            # Threat no longer exists - maneuver complete
            events.append(TacticalEvent(
                event_type=TacticalEventType.MANEUVER_COMPLETE,
                priority=2,
                details={'maneuver': 'evade', 'threat_id': cmd.threat_id},
                timestamp=battle_state.timestamp,
            ))
            return

        # Calculate evasion vector (perpendicular to threat approach)
        threat_vector = threat.velocity / np.linalg.norm(threat.velocity)
        own_pos = battle_state.own_ship.position

        # Create perpendicular vector using cross product with "up"
        up = np.array([0.0, 0.0, 1.0])
        evade_direction = np.cross(threat_vector, up)
        if np.linalg.norm(evade_direction) < 0.01:
            # Threat is coming from above/below, use different reference
            evade_direction = np.cross(threat_vector, np.array([1.0, 0.0, 0.0]))

        evade_direction = evade_direction / np.linalg.norm(evade_direction)

        # Apply evasive thrust
        outputs['thrust_vector'] = evade_direction
        outputs['thrust_magnitude'] = 1.0  # Full thrust for evasion

    def _auto_point_defense(
        self,
        battle_state: BattleState,
        outputs: dict,
    ) -> None:
        """Automatically engage interceptable threats with point defense."""
        interceptable_threats = [
            t for t in battle_state.incoming_threats
            if t.can_be_intercepted
        ]

        # Sort by time to impact (most urgent first)
        interceptable_threats.sort(key=lambda t: t.estimated_time_to_impact)

        # Assign PD to most urgent threats
        outputs['point_defense_targets'] = [t.threat_id for t in interceptable_threats[:2]]

    def _check_critical_conditions(
        self,
        battle_state: BattleState,
        events: list[TacticalEvent],
    ) -> None:
        """Check for critical conditions that warrant LLM attention."""
        own_ship = battle_state.own_ship

        # Heat critical
        if own_ship.heat_percentage >= 90:
            events.append(TacticalEvent(
                event_type=TacticalEventType.HEAT_CRITICAL,
                priority=5,
                details={'heat_percentage': own_ship.heat_percentage},
                timestamp=battle_state.timestamp,
            ))

        # Critical damage check
        total_hp = sum(hp for hp, _ in own_ship.hull_hp.values())
        total_max = sum(max_hp for _, max_hp in own_ship.hull_hp.values())
        if total_hp / total_max < 0.25:
            events.append(TacticalEvent(
                event_type=TacticalEventType.CRITICAL_DAMAGE,
                priority=5,
                details={'hull_percentage': total_hp / total_max * 100},
                timestamp=battle_state.timestamp,
            ))

        # Low delta-v warning
        if own_ship.delta_v_remaining < 50_000:  # Less than 50 km/s
            events.append(TacticalEvent(
                event_type=TacticalEventType.LOW_DELTA_V,
                priority=3,
                details={'delta_v_remaining': own_ship.delta_v_remaining},
                timestamp=battle_state.timestamp,
            ))

        # Incoming torpedo warning
        for threat in battle_state.incoming_threats:
            if threat.threat_type == 'torpedo' and threat.estimated_time_to_impact < self.evade_threshold_seconds:
                events.append(TacticalEvent(
                    event_type=TacticalEventType.TORPEDO_INCOMING,
                    priority=4,
                    details={
                        'threat_id': threat.threat_id,
                        'eta_seconds': threat.estimated_time_to_impact,
                    },
                    timestamp=battle_state.timestamp,
                ))

        # Weapons depleted check
        weapons_empty = all(
            status.get('ammo', 1) == 0
            for status in own_ship.weapons_status.values()
            if 'torpedo' not in status.get('type', '').lower()
        )
        if weapons_empty:
            events.append(TacticalEvent(
                event_type=TacticalEventType.WEAPONS_DEPLETED,
                priority=4,
                details={},
                timestamp=battle_state.timestamp,
            ))

    def _detect_enemy_maneuvers(
        self,
        battle_state: BattleState,
        events: list[TacticalEvent],
    ) -> None:
        """Detect significant changes in enemy behavior."""
        for enemy in battle_state.enemy_ships:
            last_pos = self._last_known_enemy_positions.get(enemy.ship_id)
            if last_pos is not None:
                # Check for significant velocity change
                expected_pos = last_pos + enemy.velocity * 1.0  # Assume 1s update
                actual_pos = enemy.position
                deviation = np.linalg.norm(actual_pos - expected_pos)

                # If deviation is significant (indicates thrust/maneuver)
                if deviation > 1000:  # More than 1km deviation
                    events.append(TacticalEvent(
                        event_type=TacticalEventType.ENEMY_MANEUVER_DETECTED,
                        priority=2,
                        details={
                            'enemy_id': enemy.ship_id,
                            'deviation_meters': deviation,
                        },
                        timestamp=battle_state.timestamp,
                    ))

            self._last_known_enemy_positions[enemy.ship_id] = enemy.position.copy()


# =============================================================================
# Strategic Controller Interface
# =============================================================================

class StrategicController(ABC):
    """
    Abstract interface for strategic decision-making controllers.

    Strategic controllers are called at configurable intervals (e.g., every 30
    seconds of simulation time) to make high-level decisions. The primary
    implementation will integrate with an LLM, but this interface allows for
    other implementations (rule-based AI, human input, etc.).

    The strategic controller receives a complete battle state snapshot and
    returns a list of commands for the tactical controller to execute until
    the next decision point.

    Attributes:
        ship_id: ID of the controlled ship.
        decision_interval: Seconds between decision calls.
    """

    def __init__(self, ship_id: ShipId, decision_interval: float = 30.0) -> None:
        """
        Initialize the strategic controller.

        Args:
            ship_id: ID of the ship to control.
            decision_interval: Seconds between decision points.
        """
        self.ship_id = ship_id
        self.decision_interval = decision_interval
        self._last_decision_time: float = 0.0

    def should_decide(self, current_time: float) -> bool:
        """
        Check if it's time for a new strategic decision.

        Args:
            current_time: Current simulation time in seconds.

        Returns:
            True if decision_interval has elapsed since last decision.
        """
        return current_time - self._last_decision_time >= self.decision_interval

    def request_decision(
        self,
        battle_state: BattleState,
        tactical_events: list[TacticalEvent],
    ) -> list[Command]:
        """
        Request a strategic decision based on current battle state.

        This method tracks decision timing and delegates to the abstract
        decide() method for actual decision-making.

        Args:
            battle_state: Current snapshot of the battle.
            tactical_events: Events accumulated since last decision.

        Returns:
            List of commands for the tactical controller.
        """
        self._last_decision_time = battle_state.timestamp
        return self.decide(battle_state, tactical_events)

    @abstractmethod
    def decide(
        self,
        battle_state: BattleState,
        tactical_events: list[TacticalEvent],
    ) -> list[Command]:
        """
        Make a strategic decision based on battle state.

        Implementations should analyze the battle state and return appropriate
        commands. This is where LLM integration would occur.

        Args:
            battle_state: Current snapshot of the battle.
            tactical_events: Events since last decision that may require attention.

        Returns:
            List of commands for the tactical controller to execute.
        """
        ...

    def on_critical_event(
        self,
        event: TacticalEvent,
        battle_state: BattleState,
    ) -> Optional[list[Command]]:
        """
        Handle a critical event that may require immediate decision.

        High-priority tactical events (priority 4-5) may trigger this callback
        outside the normal decision interval. Implementations can choose to
        respond immediately or defer to the next scheduled decision.

        Args:
            event: The critical tactical event.
            battle_state: Current battle state.

        Returns:
            Optional list of commands for immediate execution, or None to
            defer to normal decision cycle.
        """
        return None


class LLMStrategicController(StrategicController):
    """
    Placeholder LLM-integrated strategic controller.

    This class provides the structure for LLM integration. The actual LLM
    calls will be implemented when the LLM framework (e.g., CrewAI) is
    integrated.

    The controller will:
    1. Format battle state for LLM consumption
    2. Send state to LLM with appropriate prompts
    3. Parse LLM response into Command objects
    4. Handle LLM errors gracefully with fallback behaviors
    """

    def __init__(
        self,
        ship_id: ShipId,
        decision_interval: float = 30.0,
        llm_model: str = "claude-3-opus",
        temperature: float = 0.3,
    ) -> None:
        """
        Initialize the LLM strategic controller.

        Args:
            ship_id: ID of the ship to control.
            decision_interval: Seconds between LLM calls.
            llm_model: Name of the LLM model to use.
            temperature: LLM temperature parameter.
        """
        super().__init__(ship_id, decision_interval)
        self.llm_model = llm_model
        self.temperature = temperature

        # Placeholder for LLM client
        self._llm_client = None

    def decide(
        self,
        battle_state: BattleState,
        tactical_events: list[TacticalEvent],
    ) -> list[Command]:
        """
        Make strategic decision using LLM.

        Currently returns a default aggressive engagement behavior.
        Will be replaced with actual LLM integration.

        Args:
            battle_state: Current battle snapshot.
            tactical_events: Recent tactical events.

        Returns:
            List of commands based on LLM decision (placeholder: default behavior).
        """
        # TODO: Implement actual LLM integration
        # For now, return default aggressive behavior
        return self._default_aggressive_behavior(battle_state)

    def _default_aggressive_behavior(self, battle_state: BattleState) -> list[Command]:
        """
        Fallback behavior when LLM is unavailable.

        Implements simple aggressive engagement:
        - Thrust toward enemy
        - Engage with all weapons
        """
        commands: list[Command] = []

        target = battle_state.primary_target
        if target is None:
            # No target - hold position
            commands.append(HoldFire())
            return commands

        # Calculate direction to target
        direction = target.position - battle_state.own_ship.position
        direction = direction / np.linalg.norm(direction)

        # Thrust toward target at 50% power
        commands.append(SetThrust(vector=direction, magnitude=0.5))

        # Rotate to face target
        commands.append(RotateTo(target_bearing=direction))

        # Engage with all available weapons
        weapon_slots = tuple(battle_state.own_ship.weapons_status.keys())
        commands.append(Engage(target_id=target.ship_id, weapon_slots=weapon_slots))

        return commands

    def _format_state_for_llm(self, battle_state: BattleState) -> str:
        """
        Format battle state as text for LLM consumption.

        This will be used when LLM integration is implemented.
        """
        # Placeholder - will be implemented with LLM framework
        return f"""
BATTLE STATE at T+{battle_state.battle_duration:.1f}s

OWN SHIP ({battle_state.own_ship.ship_id}):
- Position: {battle_state.own_ship.position}
- Velocity: {battle_state.own_ship.velocity}
- Heat: {battle_state.own_ship.heat_percentage:.1f}%
- Delta-V remaining: {battle_state.own_ship.delta_v_remaining:.0f} m/s

ENEMY:
- Range: {battle_state.engagement_range:.0f} m
- Closing rate: {battle_state.closing_rate:.1f} m/s
- Threats: {len(battle_state.incoming_threats)} incoming

RECENT EVENTS: {len(battle_state.recent_events)} events
"""


class RuleBasedStrategicController(StrategicController):
    """
    Simple rule-based strategic controller for testing.

    Implements basic combat logic without LLM integration:
    - Close to weapon range
    - Engage when in range
    - Evade incoming torpedoes
    - Disengage if critically damaged
    """

    def __init__(
        self,
        ship_id: ShipId,
        decision_interval: float = 10.0,
        preferred_range: float = 150_000,
    ) -> None:
        """
        Initialize rule-based controller.

        Args:
            ship_id: ID of controlled ship.
            decision_interval: Seconds between decisions.
            preferred_range: Preferred combat range in meters.
        """
        super().__init__(ship_id, decision_interval)
        self.preferred_range = preferred_range

    def decide(
        self,
        battle_state: BattleState,
        tactical_events: list[TacticalEvent],
    ) -> list[Command]:
        """
        Make decision based on simple rules.

        Priority order:
        1. Evade critical threats
        2. Manage range
        3. Engage target
        """
        commands: list[Command] = []

        # Priority 1: Evade critical threats
        critical_threats = battle_state.critical_threats
        if critical_threats:
            most_urgent = min(critical_threats, key=lambda t: t.estimated_time_to_impact)
            commands.append(Evade(threat_id=most_urgent.threat_id))
            # Still try to fire while evading
            target = battle_state.primary_target
            if target:
                commands.append(Engage(
                    target_id=target.ship_id,
                    weapon_slots=('turret_dorsal', 'turret_ventral'),
                ))
            return commands

        # Priority 2: Manage range
        target = battle_state.primary_target
        if target is None:
            commands.append(HoldFire())
            return commands

        direction_to_target = target.position - battle_state.own_ship.position
        distance = np.linalg.norm(direction_to_target)
        direction_to_target = direction_to_target / distance

        if distance > self.preferred_range * 1.2:
            # Too far - close in
            commands.append(SetThrust(vector=direction_to_target, magnitude=0.7))
        elif distance < self.preferred_range * 0.8:
            # Too close - back off
            commands.append(SetThrust(vector=-direction_to_target, magnitude=0.5))
        else:
            # Good range - match velocity
            commands.append(SetThrust(vector=np.zeros(3), magnitude=0.0))

        # Always face target
        commands.append(RotateTo(target_bearing=direction_to_target))

        # Priority 3: Engage with all weapons
        weapon_slots = tuple(battle_state.own_ship.weapons_status.keys())
        commands.append(Engage(target_id=target.ship_id, weapon_slots=weapon_slots))

        return commands

    def on_critical_event(
        self,
        event: TacticalEvent,
        battle_state: BattleState,
    ) -> Optional[list[Command]]:
        """React immediately to critical events."""
        if event.event_type == TacticalEventType.TORPEDO_INCOMING:
            # Immediate evasion
            threat_id = event.details.get('threat_id')
            if threat_id:
                return [Evade(threat_id=threat_id)]

        if event.event_type == TacticalEventType.HEAT_CRITICAL:
            # Stop firing, reduce thrust
            return [
                HoldFire(include_point_defense=False),
                SetThrust(vector=np.zeros(3), magnitude=0.0),
            ]

        return None


# =============================================================================
# Command Validation
# =============================================================================

def validate_command(command: Command, ship_state: ShipState) -> tuple[bool, str]:
    """
    Validate that a command can be executed given current ship state.

    Args:
        command: The command to validate.
        ship_state: Current state of the ship.

    Returns:
        Tuple of (is_valid, error_message). If valid, error_message is empty.
    """
    if ship_state.is_destroyed:
        return False, "Ship is destroyed"

    if isinstance(command, SetThrust):
        if ship_state.delta_v_remaining <= 0 and command.magnitude > 0:
            return False, "No delta-v remaining"
        if ship_state.is_disabled:
            return False, "Ship is disabled"

    elif isinstance(command, RotateTo):
        # RCS typically works unless ship is destroyed
        pass

    elif isinstance(command, Engage):
        # Check if at least one weapon slot exists
        valid_slots = [s for s in command.weapon_slots if s in ship_state.weapons_status]
        if not valid_slots:
            return False, "No valid weapon slots specified"

    elif isinstance(command, Evade):
        if ship_state.delta_v_remaining < 1000:  # Need at least 1 km/s
            return False, "Insufficient delta-v for evasion"

    return True, ""
